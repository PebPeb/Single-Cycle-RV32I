$date
	Thu Jan 26 10:44:44 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module top_tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module UUT $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 # pc [31:0] $end
$var wire 32 $ inst [31:0] $end
$var wire 1 % dmemWE $end
$var wire 3 & dmemMode [2:0] $end
$var wire 32 ' dmemDataStore [31:0] $end
$var wire 32 ( dmemDataRead [31:0] $end
$var wire 32 ) dmemAdrs [31:0] $end
$scope module RV32I_Logic $end
$var wire 1 ! clk $end
$var wire 32 * dmemAdrs [31:0] $end
$var wire 1 " reset $end
$var wire 1 + rs2SEL $end
$var wire 1 , rs1SEL $end
$var wire 1 - regWE $end
$var wire 2 . regSEL [1:0] $end
$var wire 2 / pcSEL [1:0] $end
$var wire 32 0 pc [31:0] $end
$var wire 32 1 inst [31:0] $end
$var wire 3 2 immSEL [2:0] $end
$var wire 1 % dmemWE $end
$var wire 3 3 dmemMode [2:0] $end
$var wire 32 4 dmemDataStore [31:0] $end
$var wire 32 5 dmemDataRead [31:0] $end
$var wire 32 6 ALUResults [31:0] $end
$var wire 4 7 ALUControl [3:0] $end
$scope module Single_Cycle_Control $end
$var wire 1 ! clk $end
$var wire 1 8 jump $end
$var wire 1 " reset $end
$var wire 7 9 opcode [6:0] $end
$var wire 32 : inst [31:0] $end
$var wire 7 ; funct7 [6:0] $end
$var wire 3 < funct3 [2:0] $end
$var reg 4 = ALUControl [3:0] $end
$var reg 3 > dmemMode [2:0] $end
$var reg 1 % dmemWE $end
$var reg 3 ? immSEL [2:0] $end
$var reg 2 @ pcSEL [1:0] $end
$var reg 2 A regSEL [1:0] $end
$var reg 1 - regWE $end
$var reg 1 , rs1SEL $end
$var reg 1 + rs2SEL $end
$upscope $end
$scope module Single_Cycle_Datapath $end
$var wire 4 B ALUControl [3:0] $end
$var wire 32 C ALUout [31:0] $end
$var wire 3 D ImmSel [2:0] $end
$var wire 2 E PCsel [1:0] $end
$var wire 1 ! clk $end
$var wire 32 F dmemrs2 [31:0] $end
$var wire 32 G pc [31:0] $end
$var wire 1 - regWE $end
$var wire 2 H regsel [1:0] $end
$var wire 1 " reset $end
$var wire 1 , rs1sel $end
$var wire 1 + rs2sel $end
$var wire 32 I wrs3 [31:0] $end
$var wire 32 J rdout2 [31:0] $end
$var wire 32 K rdout1 [31:0] $end
$var wire 32 L pcplus4 [31:0] $end
$var wire 32 M pcPlusImm [31:0] $end
$var wire 32 N muxrs2 [31:0] $end
$var wire 32 O muxrs1 [31:0] $end
$var wire 32 P dmemData [31:0] $end
$var wire 32 Q PC_now [31:0] $end
$var wire 32 R PC_next [31:0] $end
$var wire 32 S Instr [31:0] $end
$var wire 32 T ExtImm [31:0] $end
$var wire 32 U ALUResults [31:0] $end
$scope module MUXrs1 $end
$var wire 1 , sel $end
$var wire 32 V y [31:0] $end
$var wire 32 W b [31:0] $end
$var wire 32 X a [31:0] $end
$upscope $end
$scope module MUXrs2 $end
$var wire 1 + sel $end
$var wire 32 Y y [31:0] $end
$var wire 32 Z b [31:0] $end
$var wire 32 [ a [31:0] $end
$upscope $end
$scope module adderImm $end
$var wire 32 \ y [31:0] $end
$var wire 32 ] b [31:0] $end
$var wire 32 ^ a [31:0] $end
$upscope $end
$scope module alu $end
$var wire 4 _ ALUControl [3:0] $end
$var wire 32 ` a [31:0] $end
$var wire 32 a a_signed [31:0] $end
$var wire 32 b b [31:0] $end
$var wire 32 c b_signed [31:0] $end
$var reg 32 d result [31:0] $end
$upscope $end
$scope module extendImm $end
$var wire 3 e ImmSrc [2:0] $end
$var wire 25 f Instr [24:0] $end
$var reg 32 g ExtImm [31:0] $end
$upscope $end
$scope module pcREG $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 h d [31:0] $end
$var reg 32 i q [31:0] $end
$upscope $end
$scope module pcmux $end
$var wire 32 j b [31:0] $end
$var wire 32 k c [31:0] $end
$var wire 32 l d [31:0] $end
$var wire 2 m sel [1:0] $end
$var wire 32 n a [31:0] $end
$var reg 32 o y [31:0] $end
$upscope $end
$scope module plus4 $end
$var wire 32 p a [31:0] $end
$var wire 32 q b [31:0] $end
$var wire 32 r y [31:0] $end
$upscope $end
$scope module regFILE $end
$var wire 1 ! clk $end
$var wire 5 s rd [4:0] $end
$var wire 32 t rdout1 [31:0] $end
$var wire 32 u rdout2 [31:0] $end
$var wire 1 " reset $end
$var wire 5 v rs1 [4:0] $end
$var wire 5 w rs2 [4:0] $end
$var wire 1 - we $end
$var wire 32 x wrs3 [31:0] $end
$var integer 32 y i [31:0] $end
$upscope $end
$scope module regmux $end
$var wire 32 z b [31:0] $end
$var wire 32 { c [31:0] $end
$var wire 32 | d [31:0] $end
$var wire 2 } sel [1:0] $end
$var wire 32 ~ a [31:0] $end
$var reg 32 !" y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module dataMemory $end
$var wire 32 "" a [31:0] $end
$var wire 1 ! clk $end
$var wire 3 #" mode [2:0] $end
$var wire 1 " reset $end
$var wire 32 $" wd [31:0] $end
$var wire 1 % we $end
$var reg 32 %" rd [31:0] $end
$var integer 32 &" i [31:0] $end
$upscope $end
$scope module instrMemory $end
$var wire 32 '" a [31:0] $end
$var wire 32 (" rd [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 ("
b0 '"
b100000000 &"
b0 %"
b0 $"
b0 #"
b0 ""
b0 !"
b0 ~
b0 }
b100 |
b0 {
b0 z
b100000 y
b0 x
b0 w
b0 v
b0 u
b0 t
b0 s
b100 r
b0 q
b100 p
b100 o
b100 n
b0 m
bx l
b0 k
b0 j
b0 i
b100 h
b0 g
b0 f
b0 e
b0 d
b0 c
b0 b
b0 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b100 Q
b0 P
b0 O
b0 N
b0 M
b100 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
08
b0 7
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
b0 .
0-
0,
0+
b0 *
b0 )
b0 (
b0 '
b0 &
0%
b0 $
b0 #
1"
0!
$end
#2
b100000 y
b100000000 &"
1!
#4
0!
0"
#6
b1000000000000 I
b1000000000000 x
b1000000000000 !"
b1000000000000 T
b1000000000000 Z
b1000000000000 ]
b1000000000000 g
b1000000000000 {
1-
b10 .
b10 A
b10 H
b10 }
b1000 Q
b1000 h
b1000 o
b100001 f
b1 s
b1 <
b110111 9
b1000010110111 $
b1000010110111 1
b1000010110111 :
b1000010110111 S
b1000010110111 ("
b1000 L
b1000 n
b1000 r
b1000 |
b1000000000100 M
b1000000000100 \
b1000000000100 k
b100 #
b100 0
b100 G
b100 '"
b100 R
b100 W
b100 ^
b100 i
b100 q
1!
#8
0!
#10
b1000000000100 I
b1000000000100 x
b1000000000100 !"
bx (
bx 5
bx P
bx ~
bx %"
b100 c
b100 N
b100 Y
b100 b
b1000000000100 )
b1000000000100 *
b1000000000100 ""
b1000000000100 6
b1000000000100 C
b1000000000100 U
b1000000000100 d
b1000000000100 j
b1000000000100 z
b100 T
b100 Z
b100 ]
b100 g
b100 {
b11 2
b11 ?
b11 D
b11 e
b1 .
b1 A
b1 H
b1 }
1+
b1100 Q
b1100 h
b1100 o
b1000000000000 a
b1000000000000 O
b1000000000000 V
b1000000000000 `
b1000000100000001 f
b100 w
b1000000000000 K
b1000000000000 X
b1000000000000 t
b1 v
b0 <
b10011 9
b10000001000000010010011 $
b10000001000000010010011 1
b10000001000000010010011 :
b10000001000000010010011 S
b10000001000000010010011 ("
b1100 L
b1100 n
b1100 r
b1100 |
b1100 M
b1100 \
b1100 k
b1000 #
b1000 0
b1000 G
b1000 '"
b1000 R
b1000 W
b1000 ^
b1000 i
b1000 q
1!
#12
0!
#14
b0 I
b0 x
b0 !"
b0 (
b0 5
b0 P
b0 ~
b0 %"
b0 c
b0 N
b0 Y
b0 b
b0 T
b0 Z
b0 ]
b0 g
b0 {
b0 2
b0 ?
b0 D
b0 e
b0 .
b0 A
b0 H
b0 }
0+
0-
b0 )
b0 *
b0 ""
b0 6
b0 C
b0 U
b0 d
b0 j
b0 z
b10000 Q
b10000 h
b10000 o
b0 f
b0 s
b0 w
b0 v
b0 9
b0 a
b0 O
b0 V
b0 `
b0 $
b0 1
b0 :
b0 S
b0 ("
b0 K
b0 X
b0 t
b10000 L
b10000 n
b10000 r
b10000 |
b1100 M
b1100 \
b1100 k
b1100 #
b1100 0
b1100 G
b1100 '"
b1100 R
b1100 W
b1100 ^
b1100 i
b1100 q
1!
#16
0!
